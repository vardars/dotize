{"version":3,"file":"dotize.cjs","sources":["../src/dotize.js"],"sourcesContent":["// Convert complex js object to dot notation js object\n// url: https://github.com/vardars/dotize\n// author: vardars\n\nconst dotize = {\n    valTypes: {\n        none: \"NONE\",\n        primitive: \"PRIM\",\n        object: \"OBJECT\",\n        array: \"ARRAY\",\n    },\n\n    getValType: function (val) {\n        if ((!val || typeof val != \"object\") && !Array.isArray(val))\n            return dotize.valTypes.primitive;\n        if (Array.isArray(val))\n            return dotize.valTypes.array;\n        if (typeof val == \"object\")\n            return dotize.valTypes.object;\n    },\n\n    getPathType: function (arrPath) {\n        var arrPathTypes = [];\n        for (var path in arrPath) {\n            var pathVal = arrPath[path];\n            if (!pathVal)\n                arrPathTypes.push(dotize.valTypes.none);\n            else if (dotize.isNumber(pathVal))\n                arrPathTypes.push(dotize.valTypes.array);\n            else\n                arrPathTypes.push(dotize.valTypes.object);\n        }\n        return arrPathTypes;\n    },\n\n    isUndefined: function (obj) {\n        return typeof obj == \"undefined\";\n    },\n\n    isNumber: function (f) {\n      // strickter number check\n      // see https://stackoverflow.com/a/52986361\n      return !isNaN(parseFloat(f)) && isFinite(f) && f.indexOf('.') === -1;\n    },\n\n    isEmptyObj: function (obj) {\n        for (var prop in obj) {\n            if (Object.hasOwnProperty.call(obj, prop))\n                return false;\n        }\n\n        return JSON.stringify(obj) === JSON.stringify({});\n    },\n\n    isNotObject: function (obj) {\n        return !obj || typeof obj != \"object\";\n    },\n\n    isEmptyArray: function (arr) {\n        return Array.isArray(arr) && arr.length == 0;\n    },\n\n    isNotArray: function (arr) {\n        return Array.isArray(arr) == false;\n    },\n\n    removeEmptyArrayItem: function (arr) {\n        return arr.filter(function (el) {\n            return el != null && el != \"\";\n        });\n    },\n\n    getFieldName: function (field, prefix, isRoot, isArrayItem, isArray) {\n        if (isArray)\n            return (prefix ? prefix : \"\") + (dotize.isNumber(field) ? \"[\" + field + \"]\" : (isRoot && !prefix ? \"\" : \".\") + field);\n        else if (isArrayItem)\n            return (prefix ? prefix : \"\") + \"[\" + field + \"]\";\n        else\n            return (prefix ? prefix + \".\" : \"\") + field;\n    },\n\n    startsWith: function (val, valToSearch) {\n        return val.indexOf(valToSearch) == 0;\n    },\n\n    convert: function (obj, prefix) {\n        var newObj = {};\n\n        // primitives\n        if (dotize.isNotObject(obj) && dotize.isNotArray(obj)) {\n            if (prefix) {\n                newObj[prefix] = obj;\n                return newObj;\n            } else {\n                return obj;\n            }\n        } else if (dotize.isEmptyArray(obj)) {\n            return obj;\n        }\n\n        return function recurse(o, p, isRoot) {\n            var isArrayItem = Array.isArray(o);\n            for (var f in o) {\n                var currentProp = o[f];\n                if (currentProp && typeof currentProp === \"object\") {\n                    if (Array.isArray(currentProp)) {\n                        if (dotize.isEmptyArray(currentProp)) {\n                            newObj[dotize.getFieldName(f, p, isRoot, false, true)] = currentProp;\n                        } else {\n                            newObj = recurse(currentProp, dotize.getFieldName(f, p, isRoot, false, true), isArrayItem); // array\n                        }\n                    } else {\n                        if (isArrayItem && dotize.isEmptyObj(currentProp) == false) {\n                            newObj = recurse(currentProp, dotize.getFieldName(f, p, isRoot, true)); // array item object\n                        } else if (dotize.isEmptyObj(currentProp) == false) {\n                            newObj = recurse(currentProp, dotize.getFieldName(f, p, isRoot)); // object\n                        } else if (dotize.isEmptyObj(currentProp)) {\n                            newObj[dotize.getFieldName(f, p, isRoot, isArrayItem)] = currentProp;\n                        }\n                    }\n                } else {\n                    if (isArrayItem || dotize.isNumber(f)) {\n                        newObj[dotize.getFieldName(f, p, isRoot, true)] = currentProp; // array item primitive\n                    } else {\n                        newObj[dotize.getFieldName(f, p, isRoot)] = currentProp; // primitive\n                    }\n                }\n            }\n\n            return newObj;\n        }(obj, prefix, true);\n    },\n\n    backward: function (obj, prefix) {\n        var newObj = {};\n        var arStartRegex = /\\[(\\d+)\\]/g;\n\n        // primitives\n        if (dotize.isNotObject(obj) && dotize.isNotArray(obj)) {\n            if (prefix) {\n                return obj[prefix];\n            } else {\n                return obj;\n            }\n        } else if (dotize.isEmptyArray(obj)) {\n            return obj;\n        }\n\n        for (var tProp in obj) {\n            var tPropVal = obj[tProp];\n\n            if (prefix) {\n                var prefixRegex = new RegExp(\"^\" + prefix);\n                tProp = tProp.replace(prefixRegex, \"\");\n            }\n\n            tProp = tProp.replace(arStartRegex, \".$1\");\n\n            if (dotize.startsWith(tProp, \".\"))\n                tProp = tProp.replace(/^\\./, \"\");\n\n            var arrPath = tProp.split(\".\");\n            var arrPathTypes = dotize.getPathType(arrPath);\n\n            // has array on root\n            if (!dotize.isUndefined(arrPathTypes) &&\n                arrPathTypes[0] == dotize.valTypes.array &&\n                Array.isArray(newObj) == false) {\n                newObj = [];\n            }\n\n            (function recurse(rPropVal, rObj, rPropValPrev, rObjPrev) {\n                var currentPath = arrPath.shift();\n                var currentPathType = arrPathTypes.shift();\n\n                if (typeof currentPath == \"undefined\" || currentPath == \"\") {\n                    newObj = rPropVal;\n                    return;\n                }\n\n                var currentPath = dotize.isNumber(currentPath) ? parseInt(currentPath) : currentPath;\n\n                // has multiple levels\n                if (arrPath.length > 0) {\n                    var nextPathTypeIsArray = arrPathTypes[0] == dotize.valTypes.array;\n                    // is not assigned before\n                    if (typeof rObj[currentPath] == \"undefined\") {\n                        if (nextPathTypeIsArray) {\n                            rObj[currentPath] = [];\n                        } else {\n                            rObj[currentPath] = {};\n                        }\n                    }\n\n                    recurse(rPropVal, rObj[currentPath], currentPath, rObj);\n                    return;\n                }\n\n                if (currentPathType == dotize.valTypes.array && rPropValPrev && rObjPrev) {\n                    if (Array.isArray(rObjPrev[rPropValPrev]) == false)\n                        rObjPrev[rPropValPrev] = [];\n                    rObjPrev[rPropValPrev].push(rPropVal);\n                } else {\n                    rObj[currentPath] = rPropVal;\n                }\n            }(tPropVal, newObj));\n        }\n\n        return newObj;\n    }\n}\n\nexport default dotize;\n"],"names":["dotize","valTypes","none","primitive","object","array","getValType","val","Array","isArray","getPathType","arrPath","arrPathTypes","path","pathVal","isNumber","push","isUndefined","obj","f","isNaN","parseFloat","isFinite","indexOf","isEmptyObj","prop","Object","hasOwnProperty","call","JSON","stringify","isNotObject","isEmptyArray","arr","length","isNotArray","removeEmptyArrayItem","filter","el","getFieldName","field","prefix","isRoot","isArrayItem","startsWith","valToSearch","convert","newObj","recurse","o","p","currentProp","backward","arStartRegex","tProp","tPropVal","prefixRegex","RegExp","replace","split","rPropVal","rObj","rPropValPrev","rObjPrev","currentPath","shift","currentPathType","parseInt"],"mappings":"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"}